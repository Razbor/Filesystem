# Filesystem
1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей и поясните, если считаете, что она могла бы быть другого типа. Команда CD является внутренней командой для работы с файлами.CD является внутренней так как не существует отдельной программы для запуска данной команды и команда выполняется непостредственно в оболочке системы.

2.Какая альтернатива без pipe для команды grep <some_string> <some_file> | wc -l?
Альтернативный способ подсчета количества строк, содержащих определенную строку в заданном файле, без использования pipe можно выполнить с помощью команды grep -c <some_string> <some_file>.

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04. 
Процесс с PID 1 который является родителем всех процессов является процесс systemd
root@vagrant:/home/vagrant# ps -p 1
    PID TTY          TIME CMD
      1 ?        00:00:03 systemd
4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
ls 2> /dev/pts/X

5. Получится ли одновременно передать команде файл на stdin и вывести её stdout в другой файл? Приведите работающий пример.
Да получится для этого необходимо сделать ввод в один файл и вывод в другой напримеh:
grep "1" < input.txt > output.txt

6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
Да возможно с использованием эмулятора xterm.

7. Выполните команду bash 5>&1. К чему она приведёт? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
Команда bash 5>&1 создает новый файловый дескриптор 5 и перенаправляет его на дескриптор 1. Команда echo netology > /proc/$$/fd/5 производит запись в файловый дескриптор 5. 
![изображение](https://github.com/Razbor/Filesystem/assets/19568831/961ee64c-5dad-4869-990f-9a2cb0cc0929)

8.Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв отображение stdout на pty?
Напоминаем: по умолчанию через pipe передаётся только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе. 
Да получится например.
![изображение](https://github.com/Razbor/Filesystem/assets/19568831/1e439a3e-b7bd-4cea-aa6a-b5ead1976eac)

9.Что выведет команда cat /proc/$$/environ? Как ещё можно получить аналогичный по содержанию вывод?
Команда выводит переменные окружения. Аналог команда env.

10. Используя man, опишите, что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
  /proc/<PID>/cmdline Этот доступный только для чтения файл содержит полную командную строку для процесса, если этот процесс не является зомби. В последнем случае в этом файле ничего нет, т. е. чтение этого файла повторится. Аргументы командной строки отображаются в этом файле как набор строк, разделенных нулевыми байтами ('\0'), с дополнительным нулевым байтом после последней строки.
   /proc/<PID>/exe этот файл представляет собой символическую ссылку, содержащую фактический путь к выполняемой команде. Эта символическая ссылка может быть разыменована обычным образом.
    
11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo. SSE 4.2
    ![изображение](https://github.com/Razbor/Filesystem/assets/19568831/6734d3f5-1123-403d-bf27-fa501e7a9072)

12.При открытии нового окна терминала и vagrant ssh создаётся новая сессия и выделяется pty.
Однако:vagrant@netology1:~$ ssh localhost 'tty'not a tty Почитайте, почему так происходит и как изменить поведение.
По умолчанию команда ssh не выделяет псевдотерминал, чтобы изменить поведение необходимо воспользоваться командой ssh -t vagrant@localhost 'tty'

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
    
14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell, который запущен без sudo под вашим пользователем. Для решения этой проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте, что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.


